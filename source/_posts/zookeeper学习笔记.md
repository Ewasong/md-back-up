---
title: zookeeper学习笔记
date: 2020-12-13 14:38:16
tags: [zookeeper]
---

# 《Zookeeper: 分布式过程协同技术详解》

# 第1章 简介

​	ZooKeeper是一种用于分布式应用程序的高性能协调服务。它在一个简单的界面中公开了常见的服务，如命名、配置管理、同步和组服务，这样您就不必从头开始编写它们了。您可以使用它来实现共识、组管理、领导人选举和出席协议。你可以根据自己的具体需要来构建它。

​	要实现主-从模式的系统，必须解决以下三个关键问题：

* 主节点崩溃。
* 从节点崩溃。
* 通信故障。



​	可以得到主-从架构的需求:

* 主节点枚举。
* 崩溃检测。
* 组成员关系管理。
* 元数据管理。



**注意：拜占庭将军问题**

​	拜 占 庭 将军 问题（ Byzantine Faults） 是指 可能 导致 一个 组件 发生 任意 行为（ 常常 是 意料之外 的） 的 故障。 这个 故障 的 组件 可能 会破 坏 应用 的 状态， 甚至 是 恶意 行为。 系统 是 建立 在 假设 会 发生 这些 故障， 需要 更高 程度 的 复制 并使 用 安全 原 语 的 基础上。 尽管 我们 从 学术 文献 中 知道， 针对 拜 占 庭 将军 问题 技术 发展 已经 取得 了 巨大 进步， 我们 还是 觉得 没有 必要 在 ZooKeeper 中 采用 这些 技术， 因此， 我们 也 避免 代码 库 中 引入 额外 的 复杂性。

​	CAP表示一致性，可用性和分区容错性。没有一个系统同时满足这三种属性。Zookeeper的设计尽可能满足一致性和可用性。在发生了网络分区时Zookeeper也停工了只读能力。

# 第2章 了解Zookeeper

## Zookeeper基础

​	很多设计一个用于协作需求的方法是提供原语列表，暴露出每个原语的实例化调用方法，并直接控制这些事例。比如可以说分布式锁机制组成了一个重要的原语，同时暴露出创建、获取和释放三个调用方法。

​	这种 设计 存在 一些 重大 的 缺陷： 首先， 我们 要么 预先 提出 一份 详尽 的 原 语 列表， 要么 提供 API 的 扩展， 以便 引入 新的 原 语； 其次， 以 这种 方式 实现 原 语 的 服务 使得 应用 丧失了 灵活性。

​	ZooKeeper 并不 直接 暴露 原 语， 取而代之， 它 暴露 了 由 一 小部分 调用 方法 组成 的 类似 文件 系统 的 API， 以便 允许 应用 实现 自己的 原 语。 我们 通常 使用 菜谱（ recipes） 来 表示 这些 原 语 的 实现。 菜谱 包括 ZooKeeper 操作 和 维护 一个 小型 的 数据 节点， 这些 节点 被称为 znode， 采用 类似于 文件 系统 的 层级 树状 结构 进行 管理。

![](https://pic.imgdb.cn/item/5fd5bdcd3ffa7d37b33a97a5.jpg)

​	针对 一个 znode， 没有 数据 常常 表达 了 重要的 信息。 比如， 在 主- 从 模式 的 例子 中， 主 节点 的 znode 没有 数据， 表示 当前 还没有 选 举出 主 节点。 而 图 中 涉及 的 一些 其他 znode 节 点在 主- 从 模式 的 配置 中非 常有 用： 

* /workers 节点 作为 父 节点， 其下 每个 znode 子 节点 保存 了 系统 中 一个 可用 从 节点 信息。 如图 2- 1 所示， 有一个 从 节点（ foot. com： 2181）。 
* /tasks 节点 作为 父 节点， 其下 每个 znode 子 节点 保存 了 所有 已经 创建 并 等待 从 节点 执行 的 任务 的 信息， 主- 从 模式 的 应用 的 客户 端 在/ tasks 下 添加 一个 znode 子 节点， 用来 表示 一个 新任务， 并 等待 任务 状态 的 znode 节点。
* /assign 节点 作为 父 节点， 其下 每个 znode 子 节点 保存 了 分配 到 某个 从 节点 的 一个 任务 信息， 当 主 节点 为某个从节点分配了一个任务，就会在/assign下增加一个子节点。

### API概述

​	ZooKeeper 的 API 暴露 了 以下 方法： 

​	**create/path data** 

​	创建 一个 名为/path 的 znode 节点， 并 包含 数据 data。 

​	**delete/path** 

​	删除 名为/path 的 znode。 

​	**exists/path** 

​	检查 是否 存在 名为/path 的 节点。 

​	**setData/path data** 

​	设置 名为/path 的 znode 的 数据 为 data。 

​	**getData/path** 

​	返回 名为/path 节点 的 数据 信息。 

​	**getChildren/path**

​	返回 所有/ path 节点 的 所有 子 节点 列表。

### znode的不同类型

​	新建znode的时候，还需要指定该结点的类型

**持久节点和临时节点**

​	持久的节点，只能调用delete删除。临时znide与之相反，当创建该节点的客户端崩溃或关闭了与ZooKeeper的连接时，阶段就会被删除。

**有序节点**

​	一个 znode 还可以 设置 为 有序（ sequential） 节点。 一个 有序 znode 节点 被 分配 唯一 个 单调 递增 的 整数。 当 创建 有序 节点 时， 一个 序号 会被 追加 到 路径 之后。 例如， 如果 一个 客户 端 创建 了 一个 有序 znode 节点， 其 路径 为/ tasks/ task-， 那么 ZooKeeper 将会 分配 一个 序号， 如 1， 并将 这个 数字 追加 到 路径 之后， 最后 该 znode 节点 为/ tasks/ task- 1。 有序 znode 通过 提供 了 创建 具有 唯一 名称 的 znode 的 简单 方式。 同时 也 通过 这种 方式 可以 直观 地 查看 znode 的 创建 顺序。

​		总之， znode 一 共有 4 种类 型： 持久 的（ persistent）、 临时 的（ ephemeral）、 持久 有序 的（ persistent_ sequential） 和 临时 有序 的（ ephemeral_ sequential）。

### 监视与通知

​	为了替换客户端轮询，ZooKeeper选择了基于通知的机制：客户端向ZooKeeper注册需要接受通知的znode，通过对znode设置监视点来接受通知。监视点是一个单词触发的操作，即监视点会触发一个通知。为了接受多个通知，客户端必须在每次通知后设置一个新的监视点。

![](https://pic.imgdb.cn/item/5fd5c1cc3ffa7d37b33edf4e.jpg)

​	通知 机制 的 一个 重要 保障 是， 对 同一个 znode 的 操作， 先向 客户 端 传送 通知， 然 后再 对 该 节点 进行 变更。 如果 客户 端 对 一个 znode 设置 了 监视 点， 而 该 znode 发生了 两个 连续 更新。 第一次 更新 后， 客户 端 在 观察 第二次 变化 前 就 接收 到了 通知， 然后 读取 znode 中的 数据。 我们 认为 主要 特性 在于 通知 机制 阻止 了 客户 端 所 观察 的 更新 顺序。 虽然 ZooKeeper 的 状态 变化 传播 给 某些 客户 端 时 更 慢， 但我 们 保障 客户 端 以 全局 的 顺序 来 观察 ZooKeeper 的 状态。

###  版本

​	每个znode都有一个版本号，随着每次变化自增。用于解决缓存不一致的情况。

## ZooKeeper架构

​	服务端运行于两种模式下：独立模式(standalone)和仲裁模式(quorum)。独立模式：有一个单独的服务器，ZooKeeper状态无法复制。在仲裁模式下，具有一组ZooKeeper服务器，我们称为ZooKeeper集合(ZooKeeper ensemble), 它们之间可以进行状态的复制，并同时为服务于客户端的请求。

![](https://pic.imgdb.cn/item/5fd5c65d3ffa7d37b344d8aa.jpg)

### ZooKeeper仲裁

​	客户端不必等待每个服务器完成数据保护后再继续，只要满足保存客户端数据的服务器的最小个数即可。

​	桶过 使用 多数 方案， 我们 就可以 容许 f 个 服务器 的 崩溃， 在这里， f 为 小于 集合 中 服务器 数量 的 一半。 例如， 如果 有 5 个 服务器， 可以 容许 最多 f= 2 个 崩溃。 在 集合 中， 服务器 的 个数 并不是 必须 为 奇数， 只是 使用 偶数 会使 得 系统 更加 脆弱。 假设 在 集合 中 使用 4 个 服务器， 那么 多数 原则 对应 的 数量 为 3 个 服务器。 然而， 这个 系统 仅能 容许 1 个 服务器 崩溃， 因为 两个 服务器 崩溃 就会 导致 系统 失去 多数 原则 的 状态。 因此， 在 4 个 服务器 的 情况下， 我们 仅能 容许 一个 服务器 崩溃， 而 法定人数 现在 却 更大， 这 意味着 对 每个 请求， 我们 需要 更多 的 确认 操作。 底线 是我 们 需要 争取 奇 数个 服务器。

### 会话

​	在执行任何请求前，必须先建立会话。会话提供了顺序保障，同一个会话的请求会以FIFO顺序执行。通常一个客户端只能打开一个会话。

## 开始使用Zookeeper

​	下载zookeeper。http://zookeeper.apache.org

​	用命令解压：

```sh
tar zxvf apache-zookeeper-3.6.2-bin.tar.gz
```

### 第一个ZooKeeper会话

​	以独立模式运行一个会话。首先重命名配置文件。

```sh
 mv conf/zoo_sample.cfg conf/zoo.cfg
```

​	最好把data目录移除/temp目录，以防止ZooKeeper填满根分区。在zoo.cfg中修改这个目录的位置。

```sh
dataDir=/usr/sorie/zookeeper
```

​	最后，启动服务器.

```sh
bin/zkServer.sh start
```

​	如果想查看服务器输出，可以运行如下命令

```sh
bin/zkServer.sh start-foreground
```



