---
title: 算法导论学习笔记第一部分
date: 2020-04-09 13:29:55
tags: [算法导论,算法]
---

# 1.基础知识

## 第一章-算法在计算中的作用

### 算法

​	算法，非正式的说，算法就是任何良定义的计算过程，该过程取自某个值或者值的集合作为输入并且产生某个值或者某个值的集合作为输出。

**数据结构**

​	数据结构是一种存储和组织数据的方式。

### 作为一种技术的算法

​	算法是一门技术，算法效率非常重要。

## 第二章-算法基础

### 2.1插入排序

​	对于少量元素的排序，它是一个有效地算法。插入排序的工作方式是像许多人排序一手扑克牌。开始时，我们的左手为空并且桌子上的牌面向下。然后我们每次从桌子上拿走一张牌并且将它插入左手中的正确位置。

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif)

```java
public static void insertionSort(int[] A) {
    for (int j = 1; j < A.length; j++) {
        int key = A[j];
        // insert A[j] into the sorted sequence A[0··j-1]
        int i = j - 1;
        while (i >= 0 && A[i] > key) {
            A[i + 1] = A[i];
            i--;
        }
        A[i+1] = key;
    }
}
```

#### 循环不变式与插入排序的正确性

​	循环表达式主要用来帮助我们理解算法的正确性。关于循环不变式，我们必须证明三条性质：

​	初始化：循环的第一次迭代之前，它为真。

​	保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍然为真。

​	终止：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于正面算法是正确的的。

​	那么对于插入排序。

​	初始化：首先正面在第一次循环迭代之前(当j=1时)。循环不变式成立。因为当前A[0··j-1]时 只是由A[0]单个元素组成。而且该子数组是排好序的。

​	保持：非形式化地，代码的5-9行，将A[j-1]，A[j-2]····等向右移动一个位置，直到找到A[j]合适的位置。第10行将A[j]插入该位置。此时子数组A[1···j]由原来在A[1···j]中的元素组成，但已按序排列。那么对for循环的下一次迭代增加j将保持循环不变式。

​	终止：最后研究再循环终止发生了什么。导致for循环的终止条件是j > (A.length-1 = n -1)。因为每次循环j增加1，那么必有j=n。在循环表达式中的将j用n代替，我们有子数组A[0..n-1]由原来在A[0··n-1]中的元素组成，但已按序排列。注意到子数组A[0··n-1]就是整个数组，我们推断出整个数组已排序。因此此算法正确。

#### 部分练习题

**2.1-2 重写过程INSERTION-SORT，使之按降序排序。**

解法1：从后往前的升序排序

```java
public static void insertionSortDesc(int[] A) {
    for (int j = A.length - 2; j >= 0; j--) {
        int key = A[j];
        // insert A[j] into the sorted sequence A[1··j-1]
        int i = j + 1;
        while (i < A.length && A[i] > key) {
            A[i - 1] = A[i];
            i++;
        }
        A[i-1] = key;
    }
}
```

解法2：从前往后的降序排序

```java
public static void insertionSortDesc2(int[] A) {
    for (int j = 1; j < A.length; j++) {
        int key = A[j];
        // insert A[j] into the sorted sequence A[1··j-1]
        int i = j - 1;
        while (i >= 0 && A[i] <= key) {   
            A[i + 1] = A[i];
            i--;
        }
        A[i+1] = key;
    }
}
```

### 2.2分析算法

​	分析算法的结果意味着预测算法所需要的资源。

#### 最坏情况和平均情况分析

​	最坏情况：即对规模为n的任何输入，算法的最长运行时间。

​	平均情况：期望运行时间。

#### 增长量级

​	我们真正感兴趣的运行时间的增长率或者增长量级。所以我们只考虑公式中最重要的项，因为当n很大时，低阶项相对来说不太重要。我们也忽略最终的项的常系数，因为对大的输入，在确定计算效率时常量因子不如增长率重要。我们记录插入排序具有最坏情况运行时间Θ(n<sup>2</sup>)。

### 2.3设计算法

#### 2.3.1 分治法

​	许多有用的算法在结构上是递归的：为了解决一个给定的问题，算法一次或多次的递归地调用其自身以解决紧密相关的若干子问题。

​	分治模式在每层递归都有三个步骤：

​	**分解**原问题为若干子问题，这些子问题是原问题的规模较小的实例。

​	**解决**这些问题，递归的求解各子问题。然而，若子问题的规模足够小，则直接求解。

​	**合并**这些子问题的解成原问题的解。

​	**归并排序**算法完全遵循分治模式。

​	**分解**：待排序的n个元素列成各具n/2个元素的两个子序列。

​	**解决**：使用归并排序递归的排序两个子序列

​	**合并**：合并两个已排序的子序列以产生已排序的答案。

```java
/**
 * 合并A[left··mid]以及A[mid··right]
 *
 * @param A     :
 * @param left  :
 * @param mid   :
 * @param right
 * @return
 * @author soriee
 * @date 2020/4/11 13:04
 */
public static void merge(int[] A, int left, int mid, int right) {
    int l1 = left;
    int l2 = mid + 1;
    int r1 = mid;
    int r2 = right;
    int[] sorted = new int[right - left + 1];
    int i = 0;
    while (l1 <= r1 && l2 <= r2) {
        if (A[l1] < A[l2]) {
            sorted[i] = A[l1++];
        } else {
            sorted[i] = A[l2++];
        }
        i++;
    }
    while (l1 <= r1) {
        sorted[i++] = A[l1++];
    }
    while (l2 <= r2) {
        sorted[i++] = A[l2++];
    }
    i = 0;
    while (left <= right) {
        A[left++] = sorted[i++];
    }
}

/**
 * @param A     : 数组
 * @param left  : 左边界
 * @param right ：右边界
 * @return
 * @author soriee
 * @date 2020/4/11 12:53
 */
public static void mergeSort(int[] A, int left, int right) {
    if (left < right) {
//      int mid = (left + right) / 2;
        //避免溢出
        int mid = left + (right - left) / 2;
        mergeSort(A, left, mid);
        mergeSort(A, mid + 1, right);
        merge(A, left, mid, right);
    }
}
```

### 思考题

2-1 //todo

### 补充

描述和图片来自：https://www.cnblogs.com/onepixel/articles/7674659.html

#### 冒泡排序

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif)

```java
public static void bubbleSort(int A[]) {
    for (int i = 0; i < A.length - 1; i++) {
        for (int j = A.length - 1; j >= i + 1; j--) {
            if (A[j] < A[j - 1]) {
                int temp = A[j];
                A[j] = A[j - 1];
                A[j - 1] = temp;
            }
        }
    }
}
```

#### 选择排序

选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 

![img](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif)

```java
public static void selectionSort(int A[]) {
    for (int i = 0; i < A.length - 1; i++) {
        int minIdex = i;
        for (int j = i + 1; j < A.length; j++) {
            if (A[j] < A[minIdex]) {
                minIdex = j;
            }
        }
        int temp = A[i];
        A[i] = A[minIdex];
        A[minIdex] = temp;
    }
}
```