---
title: C专家编程学习笔记
date: 2021-01-06 21:24:06
tags: [C语言]
---

# 第1章 C:穿越时空的迷雾

赋值合法必须满足下列条件之一：

​	两个操作数都是指向有限定符或者无限定符的相融类型的指针，左边指针所指向的类型必须具有右边指针所指向类型的全部限定符。

​	`char **`和`const char **`都是没有限定符的指针类型, 但是它们所指向的类型不一样。前者指向`char *`, 后者指向`const char *`。

**容易混淆的const**

​	关键字const不能把变量变成常量，只是代表这个符号不能被复制。

```c
const int * limitp = &limit; // 可以修改指针但是不能通过指针修改值。
int i = 27;
int limitp = &i;
```

## 1.10 "安静的改变"究竟有多少安静

**字符和整型(整型升级)**

​	char、short int或者int型位段（bit-field），包括它们的有符号或无符号变体，以及枚举类型，可以使用在需要int或unsigned int的表达式中。如果int可以完整表示源类型的所有值[5]，那么该源类型的值就转换为int，否则转换为unsigned int。这称为整型升级。

**寻常算术转换**

​	首先，如果其中一个操作数的类型是long double，那么另一个操作数也被转换为long double。其次，如果其中一个操作数的类型是double，那么另一个操作数也被转换为double。最后，如果其中一个操作数的类型是float，那么另一个操作数也被转换为float。否则，两个操作数进行整型升级（第6.2.1.1节描述整型升级），并执行下面的规则。

​	如果其中一个操作数的类型是unsigned long int，那么另一个操作数也被转换为unsigned long int。其次，如果其中一个操作数的类型是long int，而另一个操作数的类型是unsigned int，如果long int能够完整表示unsigned int的所有值[6]，那么unsigned int类型操作数被转换为long int；如果long int不能完整表示unsigned int的所有值[7]，那么两个操作数都被转换为unsigned long int。再次，如果其中一个操作数的类型是long int，那么另一个操作数被转换为long int。最后，如果其中一个操作数的类型是unsigned int，那么另一个操作数被转换为unsigned int。如果所有以上情况都不属于，那么两个操作数都为int。

​	**采用通俗语言来说（当然存有漏洞，而且不够精确），ANSI C标准所表示的意思大致如下：**

​	当执行算术运算时，操作数的类型如果不同，就会发生转换。数据类型一般朝着浮点精度更高、长度更长的方向转换。整型数如果转换为signed不会丢失信息，就转换为signed，否则转换为unsigned。



​	K&R C采用无符号保留（unsigned preserving）原则，就是当一个无符号类型与int或更小的整型混合使用时，结果类型是无符号类型。这是个简单的规则，与硬件无关。但是，正如下面的例子所展示的那样，它有时会使一个负数丢失符号位。

​	ANSI C标准则采用值保留（value preserving）原则，就是当把几个整型操作数混合使用时（如下面的程序所示），结果类型既有可能是有符号数，也可能是无符号数，具体取决于操作数的类型的相对大小。

![](https://pic.imgdb.cn/item/5ff5c08c3ffa7d37b306d12f.jpg)

**对无符号类型的建议**

​	尽量不要在代码中使用无符号类型，以避免不必要的复杂性，尤其是不要仅仅因为无符号数不存在负数，就用它来表示数量。

​	尽量使用像int那样的有符号类型，这样在涉及升级混合类型的复杂细节时，不必担心边界情况（如−1被翻译为非常大的正数）。只有在使用位段和二进制掩码时，才可以用无符号数。

​	应该在表达式中使用强制类型转换，使操作数均为有符号数或者无符号数，这样就不必由编译器来选择结果的类型。

## 1.11 轻松一下——由编译器定义的Pragmas效果

略

# 第2章 这不是Bug, 而是语言特性

**NUL和NULL**

​	NUL用于结束一个字符串。

​	NULL代表空指针。

**相邻的字符串常量将被自动合并成一个字符串**

​	这种做法要注意字符串数组不要少写。

### 太多的缺省可见性

![](https://pic.imgdb.cn/item/5ff5cbbd3ffa7d37b318a134.jpg)

### 运算优先级存在的问题

![](https://pic.imgdb.cn/item/5ff5cc6e3ffa7d37b319afc8.jpg)

![](https://pic.imgdb.cn/item/5ff5cd293ffa7d37b31adb1d.jpg)

还有强制转换的优先级可能比较高

```c
int a = 2;
bool eq = (bool) a == 1; // eq == true
```

### 编译器日期被破坏

![](https://pic.imgdb.cn/item/5ff71b753ffa7d37b37576a1.jpg)

​	当控制流离开声明自动变量（即局部变量）的范围时，自动变量便自动失效。

​	最好的解决方案是要求调用者分配内存来保存函数的返回值。为了提高安全性，调用者应该同时指定缓冲区的大小。

# 第3章 分析C语言的声明

## 声明是如何形成的

![](https://pic.imgdb.cn/item/5ff721863ffa7d37b3796cbb.jpg)

![](https://pic.imgdb.cn/item/5ff721973ffa7d37b3797890.jpg)

![](https://pic.imgdb.cn/item/5ff7225b3ffa7d37b37a05e5.jpg)

* 函数的返回值不能是一个函数。
* 翻书的返回值不能是一个数组。
* 数组里不能有函数。

下面是合法的：

* 函数的返回值允许时一个函数指针, `int(* fun())()`;
* 函数的返回值允许时一个指向数组的指针, `int(* foo())[]`;
* 数组里允许有函数指针, 如 `int(* foo[])()`;
* 数组里面允许有其他数组。

**理解C语言声明的优先级**

* 从它的名字开始读取，然后按照优先级顺序依次读写。
* 优先级从高 到底依次如下
  * 声明中被括号括起来那部分。
  * 后缀操作符:
    * 括号表示这是一个函数，而方括号表示是一个数组。
  * 前缀操作符：星号表示指针。
* 如果const或volatile关键字后面紧跟类型说明符，那么作用于类型说明符。其他情况作用于它坐标紧邻的指针。

![](https://pic.imgdb.cn/item/5ff724ca3ffa7d37b37be27c.jpg)

![](https://pic.imgdb.cn/item/5ff724e13ffa7d37b37bf58c.jpg)

​	这个声明表示“next是一个指针，它指向一个函数，该函数返回另一个指针，该指针指向一个类型为char的常量指针”

## typedef可以成为你的朋友

​	typedef类似于宏文本替换，但是存在一些关键性区别。

​	一般情况下, typedef用于简介地表示指向其他东西的指针。

* **不要在一个typedef中放入几个声明器**。
* 千万不要把typedef嵌到声明的中间部分。

## `typedef int x[10]`和`#define x int[10]`的区别

* 可以用其他类型说明符对宏类型名进行扩展，但对typedef所定义的类型名却不能这样做。
* 可以用其他类型说明符对宏类型名进行扩展，但对typedef所定义的类型名却不能这样做。

## `type struct foo{...foo;}`的含义

​	在同一个名字空间里，任何名字必须具有唯一性，但在不同的名字空间里可以存在相同的名字。由于每个结构或联合具有自己的名字空间，所以同一个名字可以出现在许多不同的结构内。有些很老式的编译器尚无法保证这一点。

​	由于在不同的名字空间内使用同一个名字是合法的，所以有时可以看到这样的代码：

![](https://pic.imgdb.cn/item/5ff7285c3ffa7d37b37e44d1.jpg)

**小提示**

​	不要为了方便起见而对结构使用typedef。这样做的唯一好处是你不必书写struct关键字，但这个关键字可以向你提示一些信息，不应该把它省掉。typedef应该用在以下几个方面。

* 数组、结构、指针以及函数的组合类型。
* 可移植类型。比如当你需要一种至少20比特的类型时，可以让它成为typedef的类型。这样，当把代码移植到不同的平台时，要选择正确的类型，如short、int、long时，只要在typedef中进行修改就可以了，无须对每个声明都加以修改。
* typedef也可以为后面的强制类型转换提供一个简单的名字，如：

![](https://pic.imgdb.cn/item/5ff728fd3ffa7d37b37ea941.jpg)

# 第4章 令人震惊的事实: 数组和指针并不相同

## 段

![](https://pic.imgdb.cn/item/6001adc03ffa7d37b37a2fe1.jpg)

* 数据段保存在目标文件中。
* BSS段不保存在目标文件中(除了记录BSS段在运行时所需的大小)。
* 文本段是最容易受优化措施影响的段。
* a.out文件大小受调试装备太下的编译影响, 但段不受影响。

## 操作系统在a.out文件里干了什么

![](https://pic.imgdb.cn/item/6001aed13ffa7d37b37b3f5d.jpg)

​	文本段包含程序的指令。链接器把指令直接从文件复制到内存中（一般使用mmap()系统调用），以后便再也不用管它。因为在典型情况下，程序的文本无论是内容还是大小都不会改变。

​	数据段包含经过初始化的全局和静态变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，并把它紧放在数据段之后。当这个内存区进入程序的地址空间后全部清零。包括数据段和BSS段的整个区段此时通常统称为数据区。这是因为在操作系统的内存管理术语中，段就是一片连续的虚拟地址，所以相邻的段被接合起来。一般情况下，在任何进程中数据段是最大的段。

​	我们仍然需要一些内存空间，用于保存局部变量、临时数据、传递到函数中的参数等。堆栈段（stack segment）就是用于这个目的。我们还需要堆（heap）空间，用于动态分配的内存。只要调用malloc()函数，就可以根据需要在堆上分配内存。

​	注意虚拟地址空间的最低部分未被映射。也就是说，它位于进程的地址空间内，但并未赋予物理地址，所以任何对它的引用都是非法的。在典型情况下，它是从地址零开始的几K字节。它用于捕捉使用空指针和小整型值的指针引用内存的情况。

​	当考虑共享库时，进程的地址空间的样子

![](https://pic.imgdb.cn/item/6001b1563ffa7d37b37d5df0.jpg)

## C语言运行时系统在a.out里干了些什么

### 堆栈段

​	堆栈是一个经典的计算机科学对象。它是一块动态内存区域，实现了一种“后进先出”的结构，有点类似于自助餐厅里叠在一起的盘子。堆栈的经典定义是它可以放置任意数量的盘子，但唯一有效的操作就是从顶部放或取一个盘子。

​	编译器设计者采用了一种稍微灵活的方法。我们可以从顶部增加或拿掉盘子，也可以修改位于堆栈中部的盘子的值。函数可以通过参数或全局指针访问它所调用的函数的局部变量。运行时系统维护一个指针（常位于寄存器中），通常称为sp，用于提示堆栈当前的顶部位置。堆栈段有3个主要的用途，其中两个跟函数有关，另一个跟表达式计算有关。

* 堆栈为函数内部声明的局部变量提供存储空间。按照C语言的术语，这些变量被称为“自动变量”。
* 进行函数调用时，堆栈存储与此有关的一些维护性信息，这些信息被称为堆栈结构（stack frame），另外一个更常用的名字是过程活动记录（precedure activation recored）。
* 堆栈也可以被用作暂时存储区。有时候程序需要一些临时存储，比如计算一个很长的算术表达式时，它可以把部分计算结果压到堆栈中，当需要时再把它从堆栈中取出。通过alloca()函数分配的内存就位于堆栈中。如果想让内存在函数调用结束之后仍然有效，就不要使用alloca()来分配（它将被下一个函数调用所覆盖）。



​	在不同的计算机架构和不同的操作系统中，堆栈的位置可能各不相同。尽管我们讨论的是堆栈的顶部，事实上在绝大多数处理器中，堆栈是向下增长的，也就是朝着低地址方向生长。

## 当函数被调用时发生了什么：过程活动记录

​	C语言自动提供的服务之一就是跟踪调用链——哪些函数调用了哪些函数，以及当下一个return语句执行后，控制将返回何处等。解决这个问题的经典机制是堆栈中的过程活动记录。

![](https://pic.imgdb.cn/item/60038f983ffa7d37b3464b9d.jpg)