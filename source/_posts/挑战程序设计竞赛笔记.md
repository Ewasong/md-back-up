---
title: 挑战程序设计竞赛笔记
date: 2020-06-15 22:35:30
tags: [算法,挑战]
---

# 第2章 初级篇

## 2.1 最基础的“穷竭搜索”

### 2.1.1 递归函数

计算递推式 n! = n * (n-1)!

```c++
int fact(int n) {
	if (n == 0) {
		return 1;
	} else {
		n * fact(n - 1);
	}
}
```

可以缓存结果

```c++
int memo[MAX_N+1]
int fib(int n) {
	if (n <= 1) {
		return n;
	}
	if (memo[n] != 0) {
		return memo[n];
	}
	return memo[n] = fib(n - 1) + fib(n - 2);
}
```

### 2.1.2 栈

java栈使用如下

```java
public class StackUse {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();
        stack.push(1);  //{1}
        stack.push(2);  //{1,2}
        stack.push(3);  //{1,2,3}
        System.out.println(stack.peek());   //3
        stack.pop();    // {1,2}
        System.out.println(stack.peek());   // 2
        stack.pop();    // {1}
        System.out.println(stack.peek());   // 1
        stack.pop();    // {}
    }
}

```

### 2.1.3 队列

```java
public class QuqueUse {
    public static void main(String[] args) {
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(1);  //{1}
        queue.offer(2);  //{1,2}
        queue.offer(3);  //{1,2,3}
        System.out.println(queue.toString());
        System.out.println(queue.peek());   //1
        queue.poll();    // {2,3}
        System.out.println(queue.peek());   // 2
        queue.poll();    // {3}
        System.out.println(queue.peek());   // 3
        queue.poll();    // {}

    }
}
```

### 2.1.4 深度优先搜索

​	搜索手段之一。从某个状态开始，不断地转移状态直到无法转移，然后退到前一步的状态，不断重复，直到找到最终解。

​	通常实现的方式有递归和栈。

### 2.1.5 宽度优先搜索

​	总是先搜索距离初始状态近的状态。

​	实现方式使用队列。

​	很容哟用来秋最短路径、最少操作等答案。

### 2.1.6 特殊状态枚举

​	C++提供了next_permutation函数用于生成n个函数的不同的排列。

```c++
do {
	//do something
} while(next_permutation(perm2, perm2 + n));
```

### 2.1.7 剪枝

​	搜索时，有时很早明确知道当前状态无论如何转移都不会存在解。这种情况下，不再继续搜索而是直接跳过，这一方法被称作剪枝。

## 2.2 一往直前！ 贪心法

​	贪心法就是遵循某种规则，不断贪心地选取当前最优策略的算法设计方法。

### 2.2.1 硬币问题

​	有1元，5元，10元，50元，100元，500元的硬币各C1,C5,C10,C50,C100,C500枚。现在要用这些硬币来支付A元，最少需要多少硬币。

​	思路：尽可能多地用面值更大的硬币即可。

### 2.2.2 区间问题

​	有n项工作，分别在si时间开始，在ti时间结束。对于每项工作，可以选择是否参加。如果参加就得全程参加。参与工作的时间段不能重叠，那么最多可以参加几项工作。

​	思路：在可选的工作中，每次都选取结束时间最早的工作。

### 2.2.3 字典序最小问题

​	**POJ 3617**

​	https://vjudge.net/problem/POJ-3617

	> 给定长度N的字符串S，要构造一个长度为N的字符串T。起初，T是一个空串，虽有反复进行下列任意操作。
	>
	> * 从S头部删除一个字符，加到T的尾部
	> * 从S的尾部删除一个字符，加到T的尾部
	>
	> 目标是要构造字典序尽量小的的字符串T

​	思路：

* 按照字典序比较S和将S反转后的字符串S1
* 如果S较小。就从S的开头取出一个文字，追加到T的末尾
* 如果S较小，就从S的末尾取出一个文字，追加到T的末尾

### 2.2.4 其他例题

​	**POJ 3069**	

​	https://vjudge.net/problem/POJ-3069

	> 直线上有N个点。点i的位置是X[i]。从这N个点钟选择若干个，给它们加上标记。对于每一个点，其距离为R以内的区域必须带有标记的点。在满足这个条件的情况下，希望能为尽可能少的点添加标记。请问至少有多少点要被加上标记。

​	思路：第一个点开始+R，然后找此范围中最右边的点X[i]，然后从X[i+1]开始不断重复该过程。



​	**POJ 3253**

​		https://vjudge.net/problem/POJ-3253

	> 农夫约翰为了修理栅栏，要讲一块很长的木板切割成N块。准备切成的模板的长度为L1、L2、...L[N], 未被切割的木板长度恰好为切割后木板长度的总和。每次切断木板时，需要的开销为这块模板的长度。请求出按目标要求将木板切割完最小的开销是多少？

​	用二叉树的来模拟切割程序，开销合计就是各个叶子节点就可以这样计算：

​	木板长度 * 节点的深度。

​	最佳切割方法首先应该具有如下性质：

​	最短的板与次短的板的节点应当是兄弟节点。对于最优解来讲，最短的板应当是深度最大的叶子节点之一。

​	时间复杂度是O（N^2)，不过可以用O(NlogN)，在2.4节介绍

### 专栏 Huffman编码

​	https://www.cnblogs.com/kubixuesheng/p/4397798.html

